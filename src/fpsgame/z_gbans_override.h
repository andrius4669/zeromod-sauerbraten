#ifndef Z_GBANS_OVERRIDE_H
#define Z_GBANS_OVERRIDE_H

#include "z_triggers.h"
#include "z_servcmd.h"

struct gbaninfo: ipmask
{
    int master;
    int save;
    char *comment;
    gbaninfo(): comment(NULL) {}
    ~gbaninfo() { if(comment) delete[] comment; }
};
vector<gbaninfo> gbans;

static void cleargbans(int m = -1)
{
    if(m < 0) loopvrev(gbans) { if(gbans[i].master >= 0) gbans.remove(i); }
    else loopvrev(gbans) if(gbans[i].master == m) gbans.remove(i);
}

static bool checkgban(uint ip)
{
    loopv(gbans) if(gbans[i].check(ip)) return true;
    return false;
}

static void addgban(int m, const char *name, clientinfo *actor = NULL, const char *comment = NULL, int save = 0)
{
    gbaninfo &ban = gbans.add();
    ban.parse(name);
    ban.master = m;
    ban.save = save;
    if(comment && *comment) ban.comment = newstring(comment);

    loopvrev(clients)
    {
        clientinfo *ci = clients[i];
        if(ci->state.aitype != AI_NONE || ci->local || ci->privilege >= PRIV_ADMIN) continue;
        if(actor && ((ci->privilege > actor->privilege && !actor->local) || ci->clientnum == actor->clientnum)) continue;
        if(checkgban(getclientip(ci->clientnum))) disconnect_client(ci->clientnum, DISC_IPBAN);
    }
}

void pban(const char *name, const char *comment, int *save) { addgban(-1, name, NULL, comment, *save); }
COMMAND(pban, "ssi");
void clearpbans(int *all) { loopvrev(gbans) if(gbans[i].master < 0 && ((*all)!=0 || !(gbans[i].save & 1))) gbans.remove(i); }
COMMAND(clearpbans, "i");

static void z_savepbans()
{
    stream *f = NULL;
    string buf;
    loopv(gbans) if(gbans[i].save & 1)
    {
        if(!f)
        {
            f = openutf8file(path("pbans.cfg", true), "w"); /* executed after server-init.cfg */
            if(!f) return;
            f->printf("// list of persistent bans. do not edit this file directly while server is running\n");
        }
        gbans[i].print(buf);
        f->printf("pban %s %s %d\n", buf, gbans[i].comment ? escapestring(gbans[i].comment) : "\"\"", gbans[i].save);
    }
    if(f) delete f;
    else remove(findfile(path("pbans.cfg", true), "r"));
}

void z_trigger_loadpbans(int type)
{
    atexit(z_savepbans);
    execfile("pbans.cfg", false);
}
Z_TRIGGER(z_trigger_loadpbans, Z_TRIGGER_STARTUP);

void z_servcmd_listpbans(int argc, char **argv, int sender)
{
    int n = 0;
    string buf;
    sendf(sender, 1, "ris", N_SERVMSG, "pbans list:");
    loopv(gbans) if(gbans[i].master < 0)
    {
        n++;
        gbans[i].print(buf);
        sendf(sender, 1, "ris", N_SERVMSG, gbans[i].comment
            ? tempformatstring("%02d %s [%c] %s", n, buf, (gbans[i].save & 1) ? 's' : 'p', gbans[i].comment)
            : tempformatstring("%02d %s [%c]",    n, buf, (gbans[i].save & 1) ? 's' : 'p'));
    }
    if(!n) sendf(sender, 1, "ris", N_SERVMSG, "no pbans found");
}
SCOMMANDA(listpbans, PRIV_ADMIN, z_servcmd_listpbans, 1);

void z_servcmd_unpban(int argc, char **argv, int sender)
{
    if(argc < 2) { sendf(sender, 1, "ris", N_SERVMSG, "please specify ban id"); return; }
    char *end = NULL;
    int id = int(strtol(argv[1], &end, 10)), n = 0, r = 0;
    if(!end) { sendf(sender, 1, "ris", N_SERVMSG, "incorrect ban id"); return; }
    loopv(gbans) if(gbans[i].master < 0)
    {
        n++;
        if((gbans[i].save & 1) && (n == id || id <= 0))
        {
            string buf;
            gbans[i].print(buf);
            sendf(sender, 1, "ris", N_SERVMSG, tempformatstring("removing pban for %s", buf));
            gbans.remove(i--);
            r = 1;
        }
    }
    if(!r) sendf(sender, 1, "ris", N_SERVMSG, tempformatstring("no pbans removed"));
}
SCOMMANDA(unpban, PRIV_ADMIN, z_servcmd_unpban, 1);

void z_servcmd_pban(int argc, char **argv, int sender)
{
    if(argc < 2) { sendf(sender, 1, "ris", N_SERVMSG, "please specify client number"); return; }
    char *end = NULL, *range = strchr(argv[1], '/');
    if(range) *range++ = 0;
    int cn = (int)strtol(argv[1], &end, 10);
    clientinfo *ci;
    if(!end || !(ci = (clientinfo *)getclientinfo(cn))) { sendf(sender, 1, "ris", N_SERVMSG, "incorrect client number"); return; }
    if(ci->local) { sendf(sender, 1, "ris", N_SERVMSG, "you cannot ban local client"); return; }
    int r;
    if(range)
    {
        end = NULL;
        r = clamp((int)strtol(range, &end, 10), 0, 32);
        if(!end || *end) r = 32;    /* failed to read int or string doesn't end after integer */
    }
    else r = 32;

    gbaninfo &b = gbans.add();
    b.mask = ENET_HOST_TO_NET_32(0xFFffFFff << (32 - r));
    b.ip = getclientip(cn) & b.mask;
    b.master = -1;
    b.save = 1;
    if(argc > 2 && argv[2] && *argv[2]) b.comment = newstring(argv[2]);

    string buf;
    b.print(buf);
    sendf(sender, 1, "ris", N_SERVMSG, tempformatstring("adding pban for %s", buf));

    clientinfo *actor = getinfo(sender);
    loopvrev(clients)
    {
        ci = clients[i];
        if(ci->state.aitype != AI_NONE || ci->local || ci->privilege >= PRIV_ADMIN) continue;
        if((ci->privilege > actor->privilege && !actor->local) || ci->clientnum == actor->clientnum) continue;
        if(checkgban(getclientip(ci->clientnum))) disconnect_client(ci->clientnum, DISC_IPBAN);
    }
}
SCOMMANDA(pban, PRIV_ADMIN, z_servcmd_pban, 2);

void z_servcmd_pbanip(int argc, char **argv, int sender)
{
    if(argc < 2) { sendf(sender, 1, "ris", N_SERVMSG, "please specify ip address"); return; }
    sendf(sender, 1, "ris", N_SERVMSG, tempformatstring("adding pban for %s", argv[1]));
    addgban(-1, argv[1], getinfo(sender), argc > 2 ? argv[2] : NULL, 1);
}
SCOMMANDA(pbanip, PRIV_ADMIN, z_servcmd_pbanip, 2);

#endif // Z_GBANS_OVERRIDE_H
