#ifndef Z_GBANS_OVERRIDE_H
#define Z_GBANS_OVERRIDE_H

#include "z_triggers.h"
#include "z_servcmd.h"

struct gbaninfo: ipmask
{
    int master;
    bool save;
};
vector<gbaninfo> gbans;

static void cleargbans(int m = -1)
{
    if(m < 0) loopvrev(gbans) { if(gbans[i].master >= 0) gbans.remove(i); }
    else loopvrev(gbans) if(gbans[i].master == m) gbans.remove(i);
}

static bool checkgban(uint ip)
{
    loopv(gbans) if(gbans[i].check(ip)) return true;
    return false;
}

static void addgban(int m, const char *name, clientinfo *actor = NULL, bool save = false)
{
    gbaninfo &ban = gbans.add();
    ban.parse(name);
    ban.master = m;
    ban.save = save;

    loopvrev(clients)
    {
        clientinfo *ci = clients[i];
        if(ci->state.aitype != AI_NONE || ci->local || ci->privilege >= PRIV_ADMIN) continue;
        if(actor && ((ci->privilege > actor->privilege && !actor->local) || ci->clientnum == actor->clientnum)) continue;
        if(checkgban(getclientip(ci->clientnum))) disconnect_client(ci->clientnum, DISC_IPBAN);
    }
}

void pban(const char *name, int *save) { addgban(-1, name, NULL, *save!=0); }
COMMAND(pban, "si");
void clearpbans() { loopvrev(gbans) if(gbans[i].master < 0) gbans.remove(i); }
COMMAND(clearpbans, "");

static void z_savepbans()
{
    stream *f = NULL;
    string buf;
    loopv(gbans) if(gbans[i].save)
    {
        if(!f)
        {
            f = openutf8file(path("pbans.cfg", true), "w"); /* executed after server-init.cfg */
            if(!f) return;
            f->printf("// list of persistent bans. do not edit this file directly while server is running\n");
        }
        gbans[i].print(buf);
        f->printf("pban %s 1\n", buf);
    }
    if(f) delete f;
    else remove(findfile(path("pbans.cfg", true), "r"));
}

void z_trigger_loadpbans(int type)
{
    atexit(z_savepbans);
    execfile("pbans.cfg", false);
}
Z_TRIGGER(z_trigger_loadpbans, Z_TRIGGER_STARTUP);

void z_servcmd_listpbans(int argc, char **argv, int sender)
{
    int n = 0;
    string buf;
    sendf(sender, 1, "ris", N_SERVMSG, "pbans list:");
    loopv(gbans) if(gbans[i].master < 0)
    {
        gbans[i].print(buf);
        sendf(sender, 1, "ris", N_SERVMSG, tempformatstring("%02d %s%s", ++n, buf, gbans[i].save ? " (S)" : ""));
    }
    if(!n) sendf(sender, 1, "ris", N_SERVMSG, "no pbans found");
}
SCOMMANDA(listpbans, PRIV_ADMIN, z_servcmd_listpbans, 1);

void z_servcmd_unpban(int argc, char **argv, int sender)
{
    if(argc < 2) { sendf(sender, 1, "ris", N_SERVMSG, "please specify ban id"); return; }
    char *end = NULL;
    int id = int(strtol(argv[1], &end, 10)), n = 0, r = 0;
    if(!end) { sendf(sender, 1, "ris", N_SERVMSG, "incorrect ban id"); return; }
    loopv(gbans) if(gbans[i].master < 0)
    {
        if(++n == id || id <= 0)
        {
            string buf;
            gbans[i].print(buf);
            sendf(sender, 1, "ris", N_SERVMSG, tempformatstring("removing pban for %s", buf));
            gbans.remove(i--);
            r = 1;
        }
    }
    if(!r) sendf(sender, 1, "ris", N_SERVMSG, tempformatstring("no pbans removed"));
}
SCOMMANDA(unpban, PRIV_ADMIN, z_servcmd_unpban, 1);

void z_servcmd_pban(int argc, char **argv, int sender)
{
    if(argc < 2) { sendf(sender, 1, "ris", N_SERVMSG, "please specify client number"); return; }
    char *end = NULL, *range = strchr(argv[1], '/');
    if(range) *range++ = 0;
    int cn = (int)strtol(argv[1], &end, 10);
    clientinfo *ci;
    if(!end || !(ci = (clientinfo *)getclientinfo(cn))) { sendf(sender, 1, "ris", N_SERVMSG, "incorrect client number"); return; }
    if(ci->local) { sendf(sender, 1, "ris", N_SERVMSG, "you cannot ban local client"); return; }
    int r;
    if(range)
    {
        end = NULL;
        r = clamp((int)strtol(range, &end, 10), 0, 32);
        if(!end || *end) r = 32;    /* failed to read int or string doesn't end after integer */
    }
    else r = 32;

    gbaninfo &b = gbans.add();
    b.mask = ENET_HOST_TO_NET_32(0xFFffFFff << (32 - r));
    b.ip = getclientip(cn) & b.mask;
    b.master = -1;
    b.save = true;

    string buf;
    b.print(buf);
    sendf(sender, 1, "ris", N_SERVMSG, tempformatstring("adding pban for %s", buf));

    clientinfo *actor = getinfo(sender);
    loopvrev(clients)
    {
        ci = clients[i];
        if(ci->state.aitype != AI_NONE || ci->local || ci->privilege >= PRIV_ADMIN) continue;
        if((ci->privilege > actor->privilege && !actor->local) || ci->clientnum == actor->clientnum) continue;
        if(checkgban(getclientip(ci->clientnum))) disconnect_client(ci->clientnum, DISC_IPBAN);
    }
}
SCOMMANDA(pban, PRIV_ADMIN, z_servcmd_pban, 1);

void z_servcmd_pbanip(int argc, char **argv, int sender)
{
    if(argc < 2) { sendf(sender, 1, "ris", N_SERVMSG, "please specify ip address"); return; }
    sendf(sender, 1, "ris", N_SERVMSG, tempformatstring("adding pban for %s", argv[1]));
    addgban(-1, argv[1], getinfo(sender), true);
}
SCOMMANDA(pbanip, PRIV_ADMIN, z_servcmd_pbanip, 1);

#endif // Z_GBANS_OVERRIDE_H
